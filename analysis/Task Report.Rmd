---
author: ''
date: ''
output:
  html_document:
    toc: yes
    toc_float: yes
    smooth_scroll: yes
    number_sections: yes
    self_contained: yes
    css: "C:/Users/nick.dawe/OneDrive - Pilbara Ports Authority/Documents/R Projects Via Git/Microsoft Planner/corp-styles.css"
  pdf_document:
    toc: no
---

```{r, echo=FALSE}
htmltools::img(src = knitr::image_uri(here::here("images", "PPA Logo.gif")), 
               alt = 'logo', 
               style = 'position:absolute; top:90px; right:50px; padding:0px;')
```

<hr>


```{css, echo=FALSE}
# Control the alignment of charts/figures:
.center {
  display: table;
  margin-right: auto;
  margin-left: auto;
}

# Insert page breaks if printing a PDF
@media all {
    .page-break { display: none; }
}
@media print {
    .page-break { display: block; break-after: page; }
}

# Include the following in the body of the markdown document to show a watermark
# <div class="watermark">DRAFT</div>

# @TOC {
#   right: 270px;
#   margin: 20px 0px 25px 0px;
# }
# 
# .main-container {
#     margin-left: 200px;
#}

```

```{r message=FALSE, warning=FALSE, include=FALSE}
#remotes::install_github("giocomai/ganttrify", dependencies = TRUE)
#library(ganttrify)
library(openxlsx)
library(ggplot2)
library(dplyr)
library(kableExtra)
library(zoo)
library(plotly)

# Parameters --------------------------------------------------------------

task_week_view_ahead <- 2 # Number of week(s) beyond and behind current week
task_week_view_behind <- 2 # Number of week(s) behind current week

interactive <-  TRUE # Use interactive charts with plotly

current_week <- strftime(Sys.Date(), format = "%Y-W%V")
last_week <- paste0(lubridate::year(Sys.Date()), sprintf("-W%02d", (lubridate::isoweek(Sys.Date())) - task_week_view_behind))


next_week <- paste0(lubridate::year(Sys.Date()), sprintf("-W%02d", (lubridate::isoweek(Sys.Date())) + task_week_view_ahead))

# plan_name_to_filter <- c("PID840 – Spoilbank Marina PMG", "Ideas Hub", "Mapping & Data Projects", "Annual Plan")
# plan_name_to_filter <- c("Annual Plan")# Used to filter report
# plan_name_to_filter <- c("PID840 – Spoilbank Marina PMG") # Used to filter report

plan_name_to_filter <- NULL

ppa_cols <- c("#5F6062", "#008C98", "#982623", "#B2B2B1", "#C49E39", 
              "#295775", "#175E62", "#8E9CA3", "#556670", "#000000")

# Import Data -------------------------------------------------------------

data_path <- here::here("data", "MS Planner Exports")

files <- list.files(data_path, pattern = "*.xlsx", full.names = TRUE)



temp <- NULL

for(i in seq_along(files)){
  
   # Extract the file modification date/time from the file info:
  planner_version <- file.info(files[i])$mtime
  
  xl_file <- readxl::read_xlsx(path = files[i])

  if(names(xl_file[1]) != "Task ID"){ # Older style of Planner Export - all on one page:
    
    plan_id <- as.character(xl_file[1, 2])
    plan_name <- names(xl_file)[2]
    
    xl_file$plan_version <- planner_version
    
    xl_file$Plan.ID <- plan_id
    
    xl_file$Plan.Name <- plan_name
    
    col_names <- make.names(xl_file[4, ])
    
    xl_file <- xl_file[-1:-4, ]
    
    names(xl_file) <- c(col_names[1:17], "Plan.Version", "Plan.ID", "Plan.Name")
    
  } else { # New planner export format - data on two spreadsheet tabs
    
    xl_file_2 <- readxl::read_xlsx(path = files[i], sheet = 2) # second tab of new format
    
    xl_file$Plan.Version <- planner_version
    
    xl_file$Plan.ID <- as.character(xl_file_2[1, 2])

    plan_name <- as.character(names(xl_file_2)[2])
    
    xl_file$Plan.Name <- plan_name
    
    col_names <- make.names(names(xl_file))
    col_names <- sub("_", ".", col_names)
    
    names(xl_file) <- col_names
    
    xl_file <- as.data.frame(xl_file)
    
  }

  temp <- rbind(temp, xl_file)
  
}

if(is.null(plan_name_to_filter)){ # If a plan name is not selected
  
  plan_name_to_filter <- unique(temp$Plan.Name)
  
} else { 
  
  plan_name_to_filter <- plan_name_to_filter
  
}

```

---
title: "`r paste0("TASK REPORT <br>", ifelse(length(plan_name_to_filter) > 1, "", toupper(plan_name_to_filter)), ' WEEK ', lubridate::isoweek(Sys.Date()))`"
---

```{r message=FALSE, warning=FALSE, include=FALSE}

plan.names <- data.frame(Plan.ID = unique(temp$Plan.ID),
                         Plan.Name = unique(temp$Plan.Name))

temp <- temp %>% tidyr::separate(Completed.Checklist.Items, 
                                 sep = "/", 
                                 into = c("done", "planned"), 
                                 convert = TRUE) %>% 
                 mutate(Week.Number.Version = strftime(Plan.Version, format = "%Y-W%V"),
                        Completed.Date = lubridate::parse_date_time(Completed.Date, orders = c("mdY", "dmY")),
                        Week.Number.Completed = strftime(Completed.Date, format = "%Y-W%V"),
                        Created.Date = lubridate::parse_date_time(Created.Date, orders = c("mdY", "dmY")),
                        Week.Number.Created = strftime(Created.Date, format = "%Y-W%V"),
                        Start.Date = lubridate::parse_date_time(Start.Date, orders = c("mdY", "dmY")),
                        Due.Date = lubridate::parse_date_time(Due.Date, orders = c("mdY", "dmY")),
                        Week.Number.Due = strftime(Due.Date, format = "%Y-W%V"),
                        Start.Date = case_when(is.na(Start.Date) ~ Created.Date,
                                               TRUE ~ Start.Date),
                        task.progress = round(done / planned, 2)) %>% 
  tidyr::replace_na(list(task.progress = 0))
  

all_planner_tasks <- temp

# How Many Times Have Due Dates Been Pushed Back? -------------------------

latest_plan_version <- all_planner_tasks %>% 
  select(Plan.ID, Plan.Version, Plan.Name) %>% 
  group_by(Plan.ID) %>% 
  filter(Plan.Version == max(Plan.Version)) %>% 
  ungroup() %>% 
  distinct()

latest_plan <- all_planner_tasks %>% 
  group_by(Plan.ID) %>% 
  filter(Plan.Version == max(Plan.Version),
         Plan.Name %in% plan_name_to_filter) %>% 
   ungroup()

plan_names <- unique(latest_plan[, c("Plan.ID", "Plan.Name")])

# Look up the Plan.ID based on the plan_name_to_filter values entered in parameters:
selected_plan <- as_tibble(latest_plan_version[grep(paste(plan_name_to_filter, collapse="|"),
                                                    latest_plan_version$Plan.Name), 1])

unique_tasks <- all_planner_tasks %>% select(Task.ID) %>% 
  distinct()

changed_due_dates <- all_planner_tasks %>% 
  filter(Plan.ID %in% selected_plan$Plan.ID) %>% 
  select(Task.ID, Due.Date) %>% 
  distinct(.keep_all = TRUE) %>%
  group_by(Task.ID) %>% 
  count() %>% 
  arrange(desc(n)) %>% 
  rename(due_date_changes = n) %>% 
  left_join(latest_plan %>% 
              filter(Plan.ID %in% selected_plan) %>% 
              select(Task.ID, Task.Name, Progress, Due.Date, Late))

# Status Over Time --------------------------------------------------------

tasks_per_week <- all_planner_tasks %>%
                 # select(Plan.ID, Plan.Name, Week.Number.Version, Plan.Version, Progress, Task.ID, Late) %>% 
                  group_by(Plan.ID, Week.Number.Version, Plan.Name) %>% 
                  mutate(newest = max(Plan.Version)) %>% 
                  filter(Plan.Version == newest,
                         Plan.ID %in% selected_plan$Plan.ID) 

tasks_over_time <- ggplot(data = tasks_per_week, aes(x = Week.Number.Version, fill = Progress)) +
    labs(title = "Cumulative Tasks by Progress",
         x = "Plan Version Week",
         y = "Total Tasks") +
  scale_fill_manual(values = ppa_cols) +
    geom_bar() +
    theme_bw() + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

if(length(plan_name_to_filter) > 1){
  
   tasks_over_time <- tasks_over_time + facet_wrap(~factor(Plan.Name))
  
}

number_active_tasks <- tasks_per_week %>% 
  filter(Plan.Version == latest_plan_version$Plan.Version,
         Progress != "Completed") %>% 
  count() %>% 
  rename(Active.Tasks = n)

# Tasks by Person ---------------------------------------------------------

tasks_by_person <- tidyr::separate_rows(data = latest_plan, Assigned.To, sep = ";")

active_tasks_assigned <- tasks_by_person %>% 
  filter(Progress != "Completed") %>% 
  group_by(Assigned.To) %>% 
  count()  

# Average number of tasks per person:
workload_ratio <- number_active_tasks$Active.Tasks / nrow(active_tasks_assigned)

plot_tasks_assigned_to <- tasks_by_person %>% 
  filter(Progress != "Completed") %>% 
  mutate(Late = case_when(Late == "false" ~ "No",
                          TRUE ~ "Yes")) %>% 
  group_by(Plan.Name, Assigned.To, Late) %>% 
  count() %>% 
  rename("Active.Tasks" = n) %>% 
  group_by(Assigned.To) %>% 
  mutate(total_tasks = sum(Active.Tasks)) %>% 
  ggplot() +
  geom_col(aes(x = reorder(Assigned.To, -total_tasks), y = Active.Tasks, fill = Late)) +
  geom_hline(yintercept = workload_ratio, colour = ppa_cols[5], size = 1.5) +
  scale_fill_manual(values = ppa_cols) +
  labs(title = "Active Tasks Assigned",
       x = "Assigned To",
       y = "Count of Active Tasks") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

if(length(plan_name_to_filter) > 1){
  
   plot_tasks_assigned_to <- plot_tasks_assigned_to + facet_wrap(~factor(Plan.Name))
  
}


# Late Tasks ----------------------------------

proportion_late_over_time <- tasks_per_week %>% 
  group_by(Plan.ID, Week.Number.Version, Plan.Name) %>% 
  mutate(Late = case_when(Late == "true" ~ "Yes",
                          TRUE ~ "No")) %>% 
  filter(Progress != "Completed") %>% 
  count(Late)

late_versus_ontime <- ggplot(data = proportion_late_over_time, aes(x = Week.Number.Version, y = n, fill = Late)) +
    labs(title = "Percentage of Late Tasks",
         x = "Plan Version Week",
         y = "Total Tasks") +
    geom_bar(position = "fill", stat = "identity") +
    scale_y_continuous(labels = scales::percent_format()) +
    scale_fill_manual(values = ppa_cols) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# Task KPIs ---------------------------------------------------------------

filtered_latest_plan <- latest_plan %>% 
  filter(Plan.ID %in% selected_plan$Plan.ID)

min_start_date <- min(c(min(filtered_latest_plan$Due.Date, na.rm = TRUE), 
                        min(filtered_latest_plan$Created.Date, na.rm = TRUE),
                        min(filtered_latest_plan$Completed.Date, na.rm = TRUE)), na.rm = TRUE)

max_end_date <- max(c(max(filtered_latest_plan$Due.Date, na.rm = TRUE), 
                      max(filtered_latest_plan$Created.Date, na.rm = TRUE), 
                      max(filtered_latest_plan$Completed.Date, na.rm = TRUE)), na.rm = TRUE)
  
weeks <- data.frame(Week.Number.Completed = strftime(seq(as.Date(min_start_date), as.Date(max_end_date), by = "week"), format = "%Y-W%V"))

planned_tasks_due <- filtered_latest_plan %>% 
  group_by(Week.Number.Due, Plan.ID) %>% 
 filter(stringr::str_detect(Labels, "Unplanned Task", negate = TRUE)) %>% 
  count() %>% 
  rename(planned.tasks.due = n,
         Week.Number.Completed = Week.Number.Due) # This enables joining later

planned_tasks_complete_ontime <- filtered_latest_plan %>% 
  filter(Progress == "Completed",
         Week.Number.Due == Week.Number.Completed,
         stringr::str_detect(Labels, "Unplanned Task", negate = TRUE)) %>% 
  group_by(Week.Number.Completed, Plan.ID) %>% 
  count() %>% 
  rename(Ontime = n)

unplanned_tasks_complete <- filtered_latest_plan %>% 
  filter(stringr::str_detect(Labels, "Unplanned Task", negate = FALSE),
         Progress == "Completed"
         ) %>% 
  group_by(Week.Number.Completed, Plan.ID) %>% 
  count() %>% 
  rename(Unplanned = n)

planned_tasks_complete_late <- filtered_latest_plan %>% 
  filter(Progress == "Completed",
         Week.Number.Due < Week.Number.Completed,
         stringr::str_detect(Labels, "Unplanned Task", negate = TRUE)) %>% 
  group_by(Week.Number.Completed, Plan.ID) %>% 
  count() %>% 
  rename(Late = n)

planned_tasks_complete_early <- filtered_latest_plan %>% 
  filter(Progress == "Completed",
         Week.Number.Due > Week.Number.Completed,
         stringr::str_detect(Labels, "Unplanned Task", negate = TRUE)) %>% 
  group_by(Week.Number.Completed, Plan.ID) %>% 
  count() %>% 
  rename(Early = n)

issues_raised <- filtered_latest_plan %>% 
  filter(stringr::str_detect(Labels, "Issue", negate = FALSE)
         ) %>% 
  group_by(Week.Number.Created, Plan.ID) %>% 
  count() %>% 
  rename(Issues.Raised = n)

tasks_kpis <- weeks %>% 
  left_join(planned_tasks_due) %>% 
  left_join(planned_tasks_complete_ontime) %>% 
  left_join(unplanned_tasks_complete) %>% 
  left_join(planned_tasks_complete_late) %>% 
  left_join(planned_tasks_complete_early) %>% 
  rename(Week.Number = Week.Number.Completed)

tasks_kpis$Plan.ID = selected_plan$Plan.ID

tasks_by_week <- tasks_kpis %>% 
  rowwise() %>% 
  mutate(Total.Tasks.Complete = sum(c_across(Ontime:Early), na.rm = TRUE)) %>% 
  left_join(issues_raised %>% rename(Week.Number = Week.Number.Created)) %>% 
  tidyr::replace_na(list(planned.tasks.due = 0,
                         Ontime = 0,
                         Unplanned = 0,
                         Late = 0,
                         Early = 0,
                         Total.Tasks.Complete = 0,
                         Issues.Raised = 0
                         )) 

current_week_report <- tasks_by_week  %>% 
  filter(Week.Number >= last_week &
           Week.Number <= next_week)

wk_report <- current_week_report %>% 
  select(Week.Number, planned.tasks.due:Issues.Raised) %>%
  tidyr::replace_na(list(planned.tasks.due = 0,
                         Ontime = 0,
                         Unplanned = 0,
                         Late = 0,
                         Early = 0,
                         Total.Tasks.Complete = 0,
                         Issues.Raised = 0
                         )) %>% 
   mutate(completion.ratio = round(Ontime/planned.tasks.due, 2),
          completion.percent = Ontime/planned.tasks.due) %>% 
  tidyr::replace_na(list(completion.ratio = 0,
                         completion.percent = 0)) %>% 
  rename("Week Number" = Week.Number,
         "Total Planned Tasks Due" = planned.tasks.due,
         "Planned Complete" = Ontime,
         "Unplanned Complete" = Unplanned,
         "Planned Complete Late" = Late,
         "Complete Early" = Early,
         "Total Tasks Complete" = Total.Tasks.Complete,
         "Issues Raised" = Issues.Raised,
         "Completion Rate" = completion.ratio#,
        # "Completion Percentage" = completion.percent
         ) %>% 
  mutate(completion.percent = scales::percent(completion.percent, accuracy = 1)) %>% 
  rename( "Completion Percentage" = completion.percent)

tasks_by_week_pivot <- tasks_by_week %>%
  select(!c(planned.tasks.due, Total.Tasks.Complete, Issues.Raised)) %>%
  tidyr::pivot_longer(!Week.Number:Plan.ID,
                      names_to = "Completed Status",
                      values_to = "count") %>% 
  left_join(plan_names)

completion_ratio <- tasks_by_week %>% 
  ungroup() %>% 
    filter(Week.Number < current_week &
           Week.Number >= "2021-W25",
            !is.na(Plan.ID)) %>% 
  mutate(completion.ratio = round(Ontime/planned.tasks.due, 2),
         # Now return the four week rolling mean
         rolling.mean = zoo::rollmean(completion.ratio, k = 4, fill = NA, align = c("right"))) %>% 
  # tidyr::replace_na(list(completion.ratio = 0)) %>% 
  tidyr::drop_na()

completion_ratio_plt <- ggplot(completion_ratio) +
  geom_line(aes(x = Week.Number, 
                y = rolling.mean, 
                group = 1), colour = ppa_cols[2], size = 1.5
            ) +
  geom_point(aes(x = Week.Number,
                 y = rolling.mean ,
                 ),
             colour = ppa_cols[2],
             size = 4) +
  # geom_hline(yintercept = mean(completion_ratio$completion.ratio, 
  #                              na.rm = TRUE), 
  #            colour = ppa_cols[5], 
  #            size = 1.5) +
  labs(title = "Planned Task Completion Rate",
       subtitle = "Four Week Rolling Average",
       x = "Week Number",
       y = "Completion Rate") +
  scale_y_continuous(labels = scales::percent_format(), limits = c(0, 1)) +
  #ylim(0, 1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, 
                                   vjust = 0.5, 
                                   hjust=1)) 

# GANTT Chart -------------------------------------------------------------

# dat_gant <- latest_plan %>% ungroup() %>% 
#   filter(Progress != "Completed", 
#          Due.Date >= as.Date(latest_plan_version$Plan.Version)) %>% 
#   select(Bucket.Name, Task.Name, Start.Date, Due.Date, Progress) %>% 
#   rename(wp = Bucket.Name, 
#          activity = Task.Name, 
#          start_date = Start.Date, 
#          end_date = Due.Date,
#          spot_type = Progress) %>% 
#   mutate(start_date = format(as.Date(start_date), "%Y-%m-%d"),
#          end_date = format(as.Date(end_date), "%Y-%m-%d"))
# 
#   ganttrify(project = dat_gant, 
#             by_date = TRUE,
#             hide_wp = F,
#             spots = dat_gant$spot_type,
#             size_text_relative = 1, 
#             axis_text_align = "left"
#             ) +
#     ggplot2::labs(title = plan_name,
#                   subtitle = paste0("Plan Version Date: ", 
#                                     format(as.Date(latest_plan_version$Plan.Version), 
#                                            "%d %B %Y")),
#                   caption = "") +
#     ggplot2::geom_vline(xintercept = as.Date(Sys.Date()), 
#                         linetype = "dashed", 
#                color = "black", size = 1) +
#     coord_cartesian(xlim = c(as.Date(Sys.Date()), 
#                            max(as.Date(dat_gant$end_date))))
```

# EXECUTIVE SUMMARY

This Task Report summarises information captured by Microsoft Planner's task management software. Data in this report is current up to `r format(max(as.Date(latest_plan_version$Plan.Version)), '%d %B %Y')`.

## Task Management Using Microsoft Planner

For the purpose of this report and the general approach to its preparation, a task is considered to be something that results in a deliverable or other tangible outcome that can be tracked. 

Examples of a task include:

* Preparation and completion of reports / management plans
* Actions leading up to a decision (record of the decision becomes the outcome)
* Preparing for a meeting or presentation that the individual is Chairing (the meeting or presentation is the outcome)
* Site visits / inspections lasting more than one hour.
    
Non-task related items include:

* Phone calls
* Normal meetings than run for one hour or less (where individuals are attendees)
* Replying to emails.

### Task Management Steps Within Microsoft Planner

Tasks are managed in Planner as follows:

1) Tasks are assigned only to people who are actively responsible for the outcome (i.e. multiple people can be assigned the same task).
2) The due date should be set according to when the outcome will be completed.
3) Long lead tasks can be identified and scheduled well in advance, their Progress status should be set to *Not Started*, until such time that work commences to deliver the outcome. 
4) Tasks are complete when the outcome has been delivered.

## Task Progress Overall

During the previous reporting week (`r wk_report[2, 1]`), **`r wk_report[2, 10]`** of planned tasks were completed on-time, with a four week rolling average completion rate of **`r  scales::percent(as.numeric(completion_ratio[nrow(completion_ratio), 11]))`**.

The following chart represents Microsoft Planner data by the week that data was exported. The chart shows a snapshot of cumulative tasks over time since the first data export. There are currently **`r number_active_tasks$Active.Tasks` active tasks** which includes "In Progress" and "Not Started" items.

::: {.center}
```{r echo=FALSE, fig.align='center'}
if(interactive == TRUE){
  plotly::ggplotly(tasks_over_time)
} else {
  tasks_over_time
}


```
:::

\newpage

## Task Summary KPIs by Week

The following table shows task KPIs by week, with the previous complete week highlighted in grey.

```{r echo=FALSE, message=FALSE, warning=FALSE}

wk_report %>% 
 select(-"Completion Rate") %>% 
  knitr::kable(align = 'c') %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
    kable_paper(full_width = TRUE) %>%
  row_spec(0, background = "#008C98", color = "white", align = 'c', extra_css = "vertical- align:middle;", bold = TRUE) %>% 
  row_spec(task_week_view_behind, background = "#5F6062", color = "white", bold = TRUE)

```

::: {.center}
```{r fig.align='center', message=FALSE, warning=FALSE, include=FALSE}

tasks_by_week_plot <- tasks_by_week_pivot %>%
  filter(Week.Number < current_week &
           Week.Number >= "2021-W29"
         ) %>%
  ggplot(aes(x = Week.Number, 
             y = count, 
             fill = `Completed Status`)) +
    labs(title = "Completed Tasks by Status",
         fill = "Status",
         y = "Tasks Complete",
         x = "Week Number") +
  geom_bar(position = "fill",stat = "identity") +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_fill_manual(values = ppa_cols) +
  theme_bw() + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

if(length(plan_name_to_filter) > 1){
  
   tasks_by_week_plot <- tasks_by_week_plot + facet_wrap(~factor(Plan.Name))
  
}

```
:::

::: {.center}
```{r echo=FALSE, message=FALSE, warning=FALSE, fig.align='center'}



if(nrow(completion_ratio) > 0) {
  
  if(interactive == TRUE){
    
  p1 <- plotly::ggplotly(tasks_by_week_plot)
  p2 <- plotly::ggplotly(completion_ratio_plt)
  plotly::subplot(p1, p2, nrows = 2)
  
} else {
  
    gridExtra::grid.arrange(tasks_by_week_plot, completion_ratio_plt,
                        ncol = 1,
                        nrow = 2)
  
}
  

} else { # Not enough weeks to calculate completion ratio
  
    if(interactive == TRUE){
      
      plotly::ggplotly(tasks_by_week_plot)

} else {
  
  tasks_by_week_plot
  
}
  
  
  
}




```
:::

\newpage

# CURRENT ISSUES

```{r echo=FALSE, message=FALSE, warning=FALSE}

open_issues <- filtered_latest_plan %>% 
  filter(stringr::str_detect(Labels, "Issue", negate = FALSE),
         Progress != "Completed")

number_of_issues <- nrow(open_issues)

if(number_of_issues > 1){
  
  issue_summary_text <- paste0("There are ", number_of_issues, " open issues, summarised in the following table.")
  
} else {
  
  issue_summary_text <- paste0("There is ", number_of_issues, " open issue, summarised in the following table.")
  
}

```

`r issue_summary_text` 

```{r echo=FALSE, message=FALSE, warning=FALSE}
open_issues %>% 
  select(Task.Name, Description, Created.Date, Assigned.To) %>%
  tidyr::replace_na(list(Description = "")) %>% 
  mutate(Created.Date = format(Created.Date,  "%d %B %Y")) %>% 
  rename("Issue" = Task.Name,
         "Assigned" = Assigned.To,
         "Raised On" = Created.Date
         ) %>%
  knitr::kable() %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
    kable_paper(full_width = TRUE) %>%
  row_spec(0, background = "#008C98", color = "white", bold = TRUE) 
```

\newpage

# TASKS DUE THIS WEEK `r lubridate::isoweek(Sys.Date())`

```{r echo=FALSE, message=FALSE, warning=FALSE}
planned_due_this_week <- planned_tasks_due %>% 
  filter(Week.Number.Completed == current_week) %>% 
  # tidyr::replace_na(list(c()))
  ungroup() %>% 
  summarise(planned.tasks.due = sum(planned.tasks.due, na.rm = TRUE)) %>% 
  select(planned.tasks.due)

current_late_tasks <- latest_plan %>% 
  filter(Late == "true") %>% 
  count()
  
```

This week, there are `r as.numeric(planned_due_this_week)` planned tasks due and `r as.numeric(current_late_tasks)` late tasks outstanding.

```{r echo=FALSE, message=FALSE, warning=FALSE}

tbl <- latest_plan %>% 
  filter(Late == "true" | 
         stringr::str_detect(Labels, "Unplanned Task") & Week.Number.Completed == current_week |
         stringr::str_detect(Labels, "Unplanned Task", negate = TRUE) & Week.Number.Due == current_week
          ) %>% 
  select(Task.Name, Due.Date, Late, Labels, Week.Number.Completed, Assigned.To, Progress, Week.Number.Due) %>% 
  mutate(status = case_when(Late == "true" ~ "Late Tasks Incomplete",
                            stringr::str_detect(Labels, "Unplanned Task") ~ "Unplanned - Complete",
                            Week.Number.Due == current_week ~ "Due This Week")) %>% 
  select(Task.Name, status, Assigned.To) %>% 
  rename("Task Name" = Task.Name, "Assigned To" = Assigned.To) %>% 
  arrange(status)

 kbl <-  kableExtra::kable(tbl[, c(1, 3)]) %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
  kable_paper(full_width = TRUE) 
 
 if(length(tbl$status) > 0){
   kbl %>% 
  kableExtra::pack_rows(index = table(tbl$status), label_row_css = "background-color: #666; color: #fff;") %>% 
     kableExtra::row_spec(0, background = "#008C98", color = "white")
 } else { # No statuses to report
   
 }
 
 
```

::: {.center}
```{r echo=FALSE, fig.align='center'}

  if(interactive == TRUE){
    
    plotly::ggplotly(late_versus_ontime)
  
  } else {
    
    late_versus_ontime
    
  }


```
:::

\newpage

# TASK ASSIGNMENT

The following chart represents the number of active tasks assigned to team members. It is important to note that a majority of tasks are shared, meaning that some tasks are counted more than once. There are currently `r number_active_tasks$Active.Tasks` active tasks with an average of `r round(workload_ratio)` active tasks per team member (represented by the horizontal yellow line below).

::: {.center}
```{r echo=FALSE, message=FALSE, warning=FALSE}

  if(interactive == TRUE){
    
    plotly::ggplotly(plot_tasks_assigned_to)
  
  } else {
    
    plot_tasks_assigned_to
    
  }



```
:::

```{r include=FALSE}
source(here::here("src", "save to excel.R"))
```
